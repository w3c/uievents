<section>
<h2 id="event-types">Event Types</h2>


The DOM Event Model allows a DOM implementation to support multiple modules of
events. The model has been designed to allow addition of new event modules in
the future. This document does not attempt to define all possible events. For
purposes of interoperability, the DOM defines a module of user interface events
including lower level device dependent events and a module of document mutation
events.

<h3 id="events-uievents">User Interface Events</h3>

	The User Interface event module contains basic event types associated with
	user interfaces and document manipulation.

	<h4 id="interface-uievent">Interface UIEvent</h4>

		<p class="intro-dom">Introduced in DOM Level 2</p>

		The {{UIEvent}} interface provides specific contextual information
		associated with User Interface events.

		To create an instance of the {{UIEvent}} interface, use the UIEvent
		constructor, passing an optional {{UIEventInit}} dictionary.

		<pre class="idl">
		[Constructor(DOMString type, optional UIEventInit eventInitDict)]
		interface UIEvent : Event {
			readonly attribute Window? view;
			readonly attribute long detail;
		};
		</pre>

		<dl>
			<dt><code>UIEvent . view</code></dt>
			<dd>
				The <code>view</code> attribute identifies the
				<code>Window</code> from which the event was generated.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>null</code>.
			</dd>

			<dt><code>UIEvent . detail</code></dt>
			<dd>
				Specifies some detail information about the {{Event}}, depending
				on the type of event.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0</code>.
			</dd>
		</dl>

		<pre class="idl">
		dictionary UIEventInit : EventInit {
			Window? view = null;
			long detail = 0;
		};
		</pre>

		<dl>
			<dt><code>UIEventInit . view</code></dt>
			<dd>
				Should be initialized to the Window object of the global
				environment in which this event will be dispatched. If this
				event will be dispatched to an element, the view property should
				be set to the Window object containing the element's
				<code>ownerDocument</code>.
			</dd>

			<dt><code>UIEventInit . detail</code></dt>
			<dd>
				This value is initialized to a number that is
				application-specific.
			</dd>
		</dl>

	<h4 id="events-uievent-types">UI Event Types</h4>

		The User Interface event types are listed below.  Some of these events
		use the {{UIEvent}} interface if generated from a user interface, but
		the {{Event}} interface otherwise, as detailed in each event.

		<h5 id="event-type-load"><dfn>load</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>load</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{UIEvent}} if generated from a user interface, {{Event}} otherwise.</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Async</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><a><code>Window</code></a>, <code>Document</code>, <code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} : common object whose
								contained resources have loaded</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when the DOM
			implementation finishes loading the resource (such as the document)
			and any dependent resources (such as images, style sheets, or
			scripts). Dependent resources that fail to load MUST NOT prevent
			this event from firing if the resource that loaded them is still
			accessible via the DOM. If this event type is dispatched,
			implementations are REQUIRED to dispatch this event at least on the
			<code>Document</code> node.</p>

			<p class="note">
			For legacy reasons, EVENT{load} events for resources inside the
			document (e.g., images) do not include the <a>Window</a> in the
			propagation path in HTML implementations. See [[HTML5]] for more
			information.
			</p>

		<h5 id="event-type-unload"><dfn>unload</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>unload</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{UIEvent}} if generated from a user interface, {{Event}} otherwise.</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><a><code>Window</code></a>, <code>Document</code>, <code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								common object whose contained resources have
								been removed</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when the DOM
			Implementation removes from the environment the resource (such as
			the document) or any dependent resources (such as images, style
			sheets, scripts). The document MUST be unloaded after the dispatch
			of this event type. If this event type is dispatched,
			implementations are REQUIRED to dispatch this event at least on
			the <code>Document</code> node.

		<h5 id="event-type-abort"><dfn>abort</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>abort</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{UIEvent}} if generated from a user interface, {{Event}} otherwise.</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><a><code>Window</code></a>, <code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								element whose resources have been stopped from
								loading without error</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when the loading of a
			resource has been aborted, such as by a user canceling the load
			while it is still in progress.

		<h5 id="event-type-error"><dfn>error</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>error</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{UIEvent}} if generated from a user interface, {{Event}} otherwise.</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Async</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><a><code>Window</code></a>, <code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								element whose resources have been stopped from
								loading due to an error</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a resource failed
			to load, or has been loaded but cannot be interpreted according to
			its semantics, such as an invalid image, a script execution error,
			or non-well-formed XML.

		<h5 id="event-type-select"><dfn>select</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>select</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{UIEvent}} if generated from a user interface, {{Event}} otherwise.</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								element whose text content has been selected</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a user selects
			some text.	This event is dispatched after the selection has occurred.

			This specification does not provide contextual information to access
			the selected text.	Where applicable, a <a>host language</a> SHOULD
			define rules for how a user MAY select content (with consideration
			for international language conventions), at what point the
			EVENT{select} event is dispatched, and how a content author MAY
			access the user-selected content.

			<p class="note">
			In order to access to user-selected content, content authors will
			use native capabilities of the <a>host languages</a>, such as the
			<code>Document.getSelection()</code> method of the HTML Editing APIs
			[[Editing]].
			</p>

			<p class="note">
			The EVENT{select} event might not be available for all elements in
			all languages.	For example, in [[HTML5]], EVENT{select} events can
			be dispatched only on form <{input}> and <{textarea}> elements.
			Implementations can dispatch EVENT{select} events in any context
			deemed appropriate, including text selections outside of form
			controls, or image or markup selections such as in SVG.
			</p>

<h3 id="events-focusevent">Focus Events</h3>

	<p class="note">
	This interface and its associated event types and
	[[#events-focusevent-event-order]]
	were designed in accordance to the concepts and guidelines defined in
	<a href="http://www.w3.org/WAI/UA/2010/ED-UAAG20-20100308/">User Agent Accessibility Guidelines 2.0</a>
	[[UAAG20]],
	with particular attention on the
	<a href="http://www.w3.org/WAI/UA/2010/ED-UAAG20-20100308/#gl-focus-mechanism">focus mechanism</a>
	and the terms defined in the
	<a href="http://www.w3.org/WAI/UA/2010/ED-UAAG20-20100308/#def-focus">glossary entry for focus</a>.
	</p>

	<h4 id="interface-focusevent">Interface FocusEvent</h4>

		<p class="intro-dom">Introduced in this specification</p>

		The {{FocusEvent}} interface provides specific contextual information
		associated with Focus events.

		To create an instance of the {{FocusEvent}} interface, use the
		FocusEvent constructor, passing an optional {{FocusEventInit}} dictionary.

		<pre class="idl">
		[Constructor(DOMString type, optional FocusEventInit eventInitDict)]
		interface FocusEvent : UIEvent {
			readonly attribute EventTarget? relatedTarget;
		};
		</pre>

		<dl>
			<dt><code>FocusEvent . relatedTarget</code></dt>
			<dd>
				Used to identify a secondary {{EventTarget}}
				related to a Focus event, depending on the type of event.

				For security reasons with nested browsing contexts, when tabbing
				into or out of a nested context, the relevant {{EventTarget}}
				SHOULD be <code>null</code>.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>null</code>.
			</dd>
		</dl>

		<pre class="idl">
		dictionary FocusEventInit : UIEventInit {
			EventTarget? relatedTarget = null;
		};
		</pre>

		<dl>
			<dt><code>FocusEventInit . relatedTarget</code></dt>
			<dd>
				The {{FocusEventInit/relatedTarget}} should be initialized to the element
				losing focus (in the case of a EVENT{focus} or EVENT{focusin}
				event) or the element gaining focus (in the case of a EVENT{blur}
				or EVENT{focusout} event).
			</dd>
		</dl>

	<h4 id="events-focusevent-event-order">Focus Event Order</h4>

		The focus events defined in this specification occur in a set order
		relative to one another.  The following is the typical sequence of
		events when a focus is shifted between elements (this order assumes
		that no element is initially focused):

		++---+------------+----------------------------------------------------+
		=| # | Event Type | Notes                                              |
		 +---+------------+----------------------------------------------------+
		+|   |            | <em>User shifts focus</em>                         |
		+| 1 | focusin    | Sent before first target element receives focus    |
		+| 2 | focus      | Sent after first target element receives focus     |
		+|   |            | <em>User shifts focus</em>                         |
		+| 3 | focusout   | Sent before first target element loses focus       |
		+| 4 | focusin    | Sent before second target element receives focus   |
		+| 5 | blur       | Sent after first target element loses focus        |
		+| 6 | focus      | Sent after second target element receives focus    |
		++---+------------+----------------------------------------------------+

		<p class="note">
		This specification does not define the behavior of focus events when
		interacting with methods such as <code>focus()</code> or
		<code>blur()</code>. See the relevant specifications where those methods
		are defined for such behavior.
		</p>

	<h4 id="events-focusevent-doc-focus">Document Focus and Focus Context</h4>

		This event module includes event types for notification of changes in
		document <a>focus</a>. There are three distinct focus contexts that are
		relevant to this discussion:

		*	The <em>operating system focus context</em> which MAY be on one of
			many different applications currently running on the computer. One
			of these applications with focus can be a browser.

		*	When the browser has focus, the user can switch (such as with the
			tab key) the <em>application focus context</em> among the different
			browser user interface fields (e.g., the Web site location bar, a
			search field, etc.). One of these user interface fields can be the
			document being shown in a tab.

		*	When the document itself has focus, the <em>document focus
			context</em> can be set to any of the focusable elements in the
			document.

		The event types defined in this specification deal exclusively with
		document focus, and the <a>event target</a> identified in the event
		details MUST only be part of the document or documents in the window,
		never a part of the browser or operating system, even when switching
		from one focus context to another.

		Normally, a document always has a focused element (even if it is the
		document element itself) and a persistent <a>focus ring</a>. When
		switching between focus contexts, the document's currently focused
		element and focus ring normally remain in their current state. For
		example, if a document has three focusable elements, with the second
		element focused, when a user changes operating system focus to another
		application and then back to the browser, the second element will still
		be focused within the document, and tabbing will change the focus to the
		third element.  A <a>host language</a> MAY define specific elements
		which might receive focus, the conditions under which an element MAY
		receive focus, the means by which focus MAY be changed, and the order
		in which the focus changes.  For example, in some cases an element might
		be given focus by moving a pointer over it, while other circumstances
		might require a mouse click. Some elements might not be focusable at
		all, and some might be focusable only by special means (clicking on the
		element), but not by tabbing to it.  Documents MAY contain multiple
		focus rings.  Other specifications MAY define a more complex focus model
		than is described in this specification, including allowing multiple
		elements to have the current focus.

	<h4 id="events-focus-types">Focus Event Types</h4>

		The Focus event types are listed below.

		<h5 id="event-type-blur"><dfn>blur</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>blur</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{FocusEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><a><code>Window</code></a>, <code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>event target</a> losing focus</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} :
								<a>event target</a> receiving focus.</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when an <a>event
			target</a> loses focus. The focus MUST be taken from the element
			before the dispatch of this event type.  This event type is similar
			to EVENT{focusout}, but is dispatched after focus is shifted, and
			does not bubble.

		<h5 id="event-type-focus"><dfn>focus</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>focus</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{FocusEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><a><code>Window</code></a>, <code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>event target</a> receiving focus</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} :
								<a>event target</a> losing focus (if any).</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when an <a>event
			target</a> receives focus. The focus MUST be given to the element
			before the dispatch of this event type.  This event type is similar
			to EVENT{focusin}, but is dispatched after focus is shifted, and
			does not bubble.

		<h5 id="event-type-focusin"><dfn>focusin</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>focusin</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{FocusEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><a><code>Window</code></a>, <code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>event target</a> receiving focus</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} :
								<a>event target</a> losing focus (if any).</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when an <a>event
			target</a> is about to receive focus. This event type MUST be
			dispatched before the element is given focus.  The <a>event
			target</a> MUST be the element which is about to receive focus.
			This event type is similar to EVENT{focus}, but is dispatched
			before focus is shifted, and does bubble.

			<p class="note">
			When using this event type, the content author can use the event's
			{{FocusEvent/relatedTarget}} attribute (or a host-language-specific
			method or means) to get the currently focused element before the
			focus shifts to the next focus <a>event target</a>, thus having
			access to both the element losing focus and the element gaining
			focus without the use of the EVENT{blur} or EVENT{focusout} event
			types.
			</p>

		<h5 id="event-type-focusout"><dfn>focusout</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>focusout</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{FocusEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><a><code>Window</code></a>, <code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>event target</a> losing focus</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{FocusEvent}}.{{FocusEvent/relatedTarget}} :
								<a>event target</a> receiving focus.</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when an <a>event
			target</a> is about to lose focus. This event type MUST be
			dispatched before the element loses focus.  The <a>event target</a>
			MUST be the element which is about to lose focus.  This event type
			is similar to EVENT{blur}, but is dispatched before focus is
			shifted, and does bubble.

<h3 id="events-mouseevents">Mouse Events</h3>

	The mouse event module originates from the [[HTML40]] <code>onclick</code>,
	<code>ondblclick</code>, <code>onmousedown</code>, <code>onmouseup</code>,
	<code>onmouseover</code>, <code>onmousemove</code>, and
	<code>onmouseout</code> attributes. This event module is specifically
	designed for use with pointing input devices, such as a mouse or a trackball.

	<h4 id="interface-mouseevent">Interface MouseEvent</h4>

		<p class="intro-dom">Introduced in DOM Level 2, modified in this
		specification
		</p>

		The {{MouseEvent}} interface provides specific contextual information
		associated with Mouse events.

		In the case of nested elements, mouse events are always targeted at the
		most deeply nested element.

		<p class="note">
		Ancestors of the targeted element can use event bubbling to obtain
		notifications of mouse events which occur within their descendent
		elements.
		</p>

		To create an instance of the {{MouseEvent}} interface, use the
		{{MouseEvent}} constructor, passing an optional {{MouseEventInit}}
		dictionary.

		<p class="note">
		When initializing {{MouseEvent}} objects using <code>initMouseEvent</code>,
		implementations can use the client coordinates {{MouseEvent/clientX}}
		and {{MouseEvent/clientY}} for calculation of other coordinates (such
		as target coordinates exposed by <a>DOM Level 0</a> implementations or
		other proprietary attributes, e.g., <code>pageX</code>).
		</p>

		<pre class="idl">
		[Constructor(DOMString type, optional MouseEventInit eventInitDict)]
		interface MouseEvent : UIEvent {
			readonly attribute long screenX;
			readonly attribute long screenY;
			readonly attribute long clientX;
			readonly attribute long clientY;

			readonly attribute boolean ctrlKey;
			readonly attribute boolean shiftKey;
			readonly attribute boolean altKey;
			readonly attribute boolean metaKey;

			readonly attribute short button;
			readonly attribute unsigned short buttons;

			readonly attribute EventTarget? relatedTarget;

			boolean getModifierState(DOMString keyArg);
		};
		</pre>

		<dl>
			<dt>MouseEvent . screenX</dt>
			<dd>
				The horizontal coordinate at which the event occurred relative
				to the origin of the screen coordinate system.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0</code>.
			</dd>

			<dt>MouseEvent . screenY</dt>
			<dd>
				The vertical coordinate at which the event occurred relative to
				the origin of the screen coordinate system.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0</code>.
			</dd>

			<dt>MouseEvent . clientX</dt>
			<dd>
				The horizontal coordinate at which the event occurred relative
				to the viewport associated with the event.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0</code>.
			</dd>

			<dt>MouseEvent . clientY</dt>
			<dd>
				The vertical coordinate at which the event occurred relative
				to the viewport associated with the event.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0</code>.
			</dd>

			<dt>MouseEvent . ctrlKey</dt>
			<dd>
				Refer to the {{KeyboardEvent/ctrlKey}} attribute.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>false</code>.
			</dd>

			<dt>MouseEvent . shiftKey</dt>
			<dd>
				Refer to the {{KeyboardEvent/shiftKey}} attribute.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>false</code>.
			</dd>

			<dt>MouseEvent . altKey</dt>
			<dd>
				Refer to the {{KeyboardEvent/altKey}} attribute.

				The <a>un-initialized value</a>
				of this attribute MUST be <code>false</code>.
			</dd>

			<dt>MouseEvent . metaKey</dt>
			<dd>
				Refer to the {{KeyboardEvent/metaKey}} attribute.

				The <a>un-initialized value</a>
				of this attribute MUST be <code>false</code>.
			</dd>

			<dt>MouseEvent . button</dt>
			<dd>
				During mouse events caused by the depression or release of a mouse button,
				<code>button</code> MUST be used to indicate which pointer device button
				changed state.

				The value of the {{MouseEvent/button}}
				attribute MUST be as follows:

				*	<code>0</code> MUST indicate the primary button of the device
					(in general, the left button  or the only button on single-button devices,
					used to activate a user interface control or select text) or the
					un-initialized value.
				*	<code>1</code> MUST indicate the auxiliary button
					(in general, the middle button, often combined with a mouse wheel).
				*	<code>2</code> MUST indicate the secondary button
					(in general, the right button, often used to display a context menu).

				Some pointing devices provide or simulate more button states, and values higher than
				<code>2</code> or lower than <code>0</code> MAY be used to represent such buttons.

				<p class="note">
				The value of {{MouseEvent/button}} is not updated for events not caused by the
				depression/release of a mouse button.
				In these scenarios, take care not to interpret the value <code>0</code> as the
				left button, but rather as the <a>un-initialized value</a>.
				</p>

				<p class="note">
				Some <a>default actions</a> related
				to events such as EVENT{mousedown} and
				EVENT{mouseup} depend on the specific mouse
				button in use.
				</p>

				The <a>un-initialized value</a>
				of this attribute MUST be <code>0</code>.
			</dd>

			<dt>MouseEvent . buttons</dt>
			<dd>
				During any mouse events, <code>buttons</code> MUST be used to
				indicate which combination of mouse buttons are currently being
				pressed, expressed as a bitmask.

				<p class="note">
				Though similarly named, the values for the
				{{MouseEvent/buttons}} attribute and the {{MouseEvent/button}}
				attribute are very different. The value of {{MouseEvent/button}}
				is assumed to be valid during EVENT{mousedown} / EVENT{mouseup}
				event handlers, whereas the {{MouseEvent/buttons}} attribute
				reflects the state of the mouse's buttons for any trusted
				{{MouseEvent}} object (while it is being dispatched), because it
				can represent the "no button currently active" state (0).
				</p>

				The value of the {{MouseEvent/buttons}}
				attribute MUST be as follows:

				*	<code>0</code> MUST indicate no button is currently active.
				*	<code>1</code> MUST indicate the primary button of the device
					(in general, the left button or the only button on single-button devices,
					used to activate a user interface control or select text).
				*	<code>2</code> MUST indicate the secondary button
					(in general, the right button, often used to display a context menu), if present.
				*	<code>4</code> MUST indicate the auxiliary button
					(in general, the middle button, often combined with a mouse wheel).

				Some pointing devices provide or simulate more buttons. To
				represent such buttons, the value MUST be doubled for each
				successive button (in the binary series <code>8</code>,
				<code>16</code>, <code>32</code>, ... ).

				<p class="note">
				Because the sum of any set of button values is a unique number,
				a content author can use a bitwise operation to determine how
				many buttons are currently being pressed and which buttons they
				are, for an arbitrary number of mouse buttons on a device. For
				example, the value <code>3</code> indicates that the left and
				right button are currently both pressed, while the value
				<code>5</code> indicates that the left and middle button are
				currently both pressed.

				<p class="note">
				Some <a>default actions</a> related to events such as
				EVENT{mousedown} and EVENT{mouseup} depend on the specific mouse
				button in use.
				</p>

				The <a>un-initialized value</a>
				of this attribute MUST be <code>0</code>.
			</dd>

			<dt>MouseEvent . relatedTarget</dt>
			<dd>
				Used to identify a secondary {{EventTarget}} related to a UI event, depending on the type of event.

				The <a>un-initialized value</a> of this attribute MUST be <code>null</code>.
			</dd>

			<dt>MouseEvent . getModifierState(keyArg)</dt>
			<dd>
				<p class="intro-dom">Introduced in this specification</p>

				Queries the state of a modifier using a key value.
				See [[#keys-modifiers]] for a list of valid (case-sensitive)
				arguments to this method.

				Returns <code>true</code> if it is a modifier key and the
				modifier is activated, <code>false</code> otherwise.

				<dl class="parameters">
					<dt>DOMString keyArg</dt>
					<dd>
						Refer to the {{KeyboardEvent}}.{{KeyboardEvent/getModifierState()}}
						method for a description of this parameter.
					</dd>
				</dl>
			</dd>
		</dl>

		<pre class="idl">
		dictionary MouseEventInit : EventModifierInit {
			long screenX = 0;
			long screenY = 0;
			long clientX = 0;
			long clientY = 0;

			short button = 0;
			unsigned short buttons = 0;
			EventTarget? relatedTarget = null;
		};
		</pre>

		<dl>
			<dt>MouseEventInit . screenX</dt>
			<dd>
				See <code>screenY</code> (substituting "horizontal" for "veritcal").
			</dd>

			<dt>MouseEventInit . screenY</dt>
			<dd>
				Initializes the <code>screenY</code> attribute of the MouseEvent
				object to the desired vertical relative position of the mouse
				pointer on the user's screen.

				Initializing the event object to the given mouse position must
				not move the user's mouse pointer to the initialized position.
			</dd>

			<dt>MouseEventInit . clientX</dt>
			<dd>
				See <code>clientY</code> (substituting "horizontal" for "vertical").
			</dd>

			<dt>MouseEventInit . clientY</dt>
			<dd>
				Initializes the <code>clientY</code> attribute of the MouseEvent
				object to the desired vertical position of the mouse pointer
				relative to the client window of the user's browser.

				Initializing the event object to the given mouse position must
				not move the user's mouse pointer to the initialized position.
			</dd>

			<dt>MouseEventInit . button</dt>
			<dd>
				Initializes the <code>button</code> attribute of the MouseEvent
				object to a number representing the desired state of the button(s)
				of the mouse.

				<p class="note">
				The value 0 is used to represent
				the primary mouse button, 1 is used to represent the auxiliary/middle
				mouse button, and 2 to represent the right mouse button.
				Numbers greater than 2 are also possible, but are not specified
				in this document.
				</p>
			</dd>

			<dt>MouseEventInit . buttons</dt>
			<dd>
				Initializes the <code>buttons</code> attribute of the MouseEvent
				object to a number representing one <em>or more</em> of the button(s) of the mouse
				that are to be considered active.

				<p class="note">
				The <code>buttons</code>
				attribute is a bit-field. If a mask value of 1 is true when applied to
				the value of the bit field, then the primary mouse button is down. If a
				mask value of 2 is true when applied to the value of the bit field, then
				the right mouse button is down. If a mask value of 4 is true when applied
				to the value of the bit field, then the auxiliary/middle button is down.
				</p>

				<p class="example">
				In JavaScript, to initialize the
				<code>buttons</code> attribute as if the right (2) and middle
				button (4) were being pressed simultaneously, the buttons value
				can be assigned as either:<br/>
				<code>&nbsp;&nbsp;{ buttons: 2 | 4 }</code></br/>
				or:<br/>
				<code>&nbsp;&nbsp;{ buttons: 6 }</code>
				</p>
			</dd>

			<dt>MouseEventInit relatedTarget</dt>
			<dd>
				The <code>relatedTarget</code> should be initialized to the element
				whose bounds the mouse pointer just left (in the case of a
				<em>mouseover</em> or <em>mouseenter</em> event) or the element
				whose bounds the mouse pointer is entering (in the case of a
				<em>mouseout</em> or <em>mouseleave</em>
				or <em>focusout</em> event). For other events, this value need not
				be assigned (and will default to null).
			</dd>

		</dl>

	<p id="current-click-count">Implementations MUST maintain the <em>current
	click count</em> when generating mouse events. This MUST be a non-negative
	integer indicating the number of consecutive clicks of a pointing device
	button within a specific time. The delay after which the count resets is
	specific to the environment configuration.
	</p>

	<h4 id="event-modifier-initializers">Event Modifier Initializers</h4>

		The {{MouseEvent}} and {{KeyboardEvent}} interfaces share a set of
		keyboard modifier attributes and support a mechanism for retrieving
		additional modifier states. The following dictionary enables authors to
		initialize keyboard modifier attributes of the {{MouseEvent}} and
		{{KeyboardEvent}} interfaces, as well as the additional modifier states
		queried via {{KeyboardEvent/getModifierState()}}. The steps for
		constructing events using this dictionary are defined in the
		<a href="#event-constructors">event constructors</a> section.

		<pre class="idl">
		dictionary EventModifierInit : UIEventInit {
			boolean ctrlKey = false;
			boolean shiftKey = false;
			boolean altKey = false;
			boolean metaKey = false;

			boolean modifierAltGraph = false;
			boolean modifierCapsLock = false;
			boolean modifierFn = false;
			boolean modifierFnLock = false;
			boolean modifierHyper = false;
			boolean modifierNumLock = false;
			boolean modifierScrollLock = false;
			boolean modifierSuper = false;
			boolean modifierSymbol = false;
			boolean modifierSymbolLock = false;
		};
		</pre>

		<dl>
			<dt>EventModifierInit . ctrlKey</dt>
			<dd>
				Initializes the <code>ctrlKey</code> attribute of the
				{{MouseEvent}} or {{KeyboardEvent}}
				objects to <code>true</code> if the KEYCAP{Control}
				key modifier is to be considered active,
				<code>false</code> otherwise.

				When <code>true</code>, implementations must also initialize the event object's key modifier
				state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{Control}
				must return <code>true</code>.
			</dd>

			<dt>EventModifierInit . shiftKey</dt>
			<dd>
				Initializes the <code>shiftKey</code> attribute of the
				{{MouseEvent}} or {{KeyboardEvent}}
				objects to <code>true</code> if the KEYCAP{Shift}
				key modifier is to be considered active, <code>false</code> otherwise.

				When <code>true</code>, implementations must also initialize the event object's key modifier
				state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{Shift} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . altKey</dt>
			<dd>
				Initializes the <code>altKey</code> attribute of the
				{{MouseEvent}} or {{KeyboardEvent}}
				objects to <code>true</code> if the KEYCAP{Alt}
				(alternative) (or KEYCAP{Option}) key modifier
				is to be considered active, <code>false</code> otherwise.

				When <code>true</code>, implementations must also initialize the event object's key modifier
				state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{Alt} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . metaKey</dt>
			<dd>
				Initializes the <code>metaKey</code> attribute of the
				{{MouseEvent}} or {{KeyboardEvent}}
				objects to <code>true</code> if the KEYCAP{Meta}
				key modifier is to be considered active, <code>false</code> otherwise.

				When <code>true</code>, implementations must also initialize the event object's
				key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with either the parameter KEYCAP{Meta}
				must return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierAltGraph</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{AltGraph} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierCapsLock</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{CapsLock} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierFn</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{Fn} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierFnLock</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{FnLock} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierHyper</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{Hyper} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierNumLock</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{NumLock} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierScrollLock</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{ScrollLock} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierSuper</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{Super} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierSymbol</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{Symbol} must
				return <code>true</code>.
			</dd>

			<dt>EventModifierInit . modifierSymbolLock</dt>
			<dd>
				Initializes the event object's key modifier state such that calls to the
				{{MouseEvent/getModifierState()}} or
				{{KeyboardEvent/getModifierState()}}
				when provided with the parameter KEYCAP{SymbolLock} must
				return <code>true</code>.
			</dd>
		</dl>

	<h4 id="events-mouseevent-event-order">Mouse Event Order</h4>

		Certain mouse events defined in this specification MUST occur in a set
		order relative to one another. The following shows the event sequence
		that MUST occur when a pointing device's cursor is moved over an element:

		++---+------------+---------+------------------------------------------+
		=| # | Event Type | Element | Notes                                    |
		 +---+------------+----o----+------------------------------------------+
		+| 1 | mousemove  |         |                                          |
		+|   |            |         | <em>Pointing device is moved into        |
		 |   |            |         | element A...</em>                        |
		+| 2 | mouseover  |    A    |                                          |
		+| 3 | mouseenter |    A    |                                          |
		+| 4 | mousemove  |    A    | Multiple EVENT{mousemove} events         |
		+|   |            |         | <em>Pointing device is moved out of      |
		 |   |            |         | element A...</em>                        |
		+| 5 | mouseout   |    A    |                                          |
		+| 6 | mouseleave |    A    |                                          |
		++---+------------+----------------------------------------------------+

		When a pointing device is moved into an element <em>A</em>, and then
		into a nested element <em>B</em> and then back out again, the following
		sequence of events MUST occur:

		++----+------------+---------+-----------------------------------------+
		=|  # | Event Type | Element | Notes                                   |
		 +----+------------+----o----+-----------------------------------------+
		+|  1 | mousemove  |         |                                         |
		+|    |            |         | <em>Pointing device is moved into       |
		 |    |            |         | element A...</em>                       |
		+|  2 | mouseover  |    A    |                                         |
		+|  3 | mouseenter |    A    |                                         |
		+|  4 | mousemove  |    A    | Multiple EVENT{mousemove} events        |
		+|    |            |         | <em>Pointing device is moved into       |
		 |    |            |         | nested element B...</em>                |
		+|  5 | mouseout   |    A    |                                         |
		+|  6 | mouseover  |    B    |                                         |
		+|  7 | mouseenter |    B    |                                         |
		+|  8 | mousemove  |    B    | Multiple EVENT{mousemove} events        |
		+|    |            |         | <em>Pointing device is moved from       |
		 |    |            |         | element B into A...</em>                |
		+|  9 | mouseout   |    B    |                                         |
		+| 10 | mouseleave |    B    |                                         |
		+| 11 | mouseover  |    A    |                                         |
		+| 12 | mousemove  |    A    | Multiple EVENT{mousemove} events        |
		+|    |            |         | <em>Pointing device is moved out of     |
		 |    |            |         | element A...</em>                       |
		+| 13 | mouseout   |    A    |                                         |
		+| 14 | mouseleave |    A    |                                         |
		++----+------------+---------------------------------------------------+

		Sometimes elements can be visually overlapped using CSS. In the
		following example, three elements labeled A, B, and C all have the same
		dimensions and absolute position on a web page. Element C is a child of
		B, and B is a child of A in the DOM:

		<figure id="figure-mouse-event-stacked-elements">
			<img src='images/stacked-event-mouse-dispatch.svg' height="250" alt="Graphical representation of three stacked elements all on top of each other. The bottom element is labeled A and the top element is C" />
			<figcaption>Graphical representation of three stacked elements all on top of each other, with the pointing device moving over the stack.</figcaption>
		</figure>

		When the pointing device is moved from outside the element stack to the
		element labeled C and then moved out again, the following series of
		events MUST occur:

		++----+------------+---------+-----------------------------------------+
		=|  # | Event Type | Element | Notes                                   |
		 +----+------------+----o----+-----------------------------------------+
		+|  1 | mousemove  |         |                                         |
		+|    |            |         | <em>Pointing device is moved into       |
		 |    |            |         | element C, the topmost element in the   |
		 |    |            |         | stack</em>                              |
		+|  2 | mouseover  |    C    |                                         |
		+|  3 | mouseenter |    A    |                                         |
		+|  4 | mouseenter |    B    |                                         |
		+|  5 | mouseenter |    C    |                                         |
		+|  6 | mousemove  |    C    | Multiple EVENT{mousemove} events        |
		+|    |            |         | <em>Pointing device is moved out of     |
		 |    |            |         | element C...</em>                       |
		+|  7 | mouseout   |    C    |                                         |
		+|  8 | mouseleave |    C    |                                         |
		+|  9 | mouseleave |    B    |                                         |
		+| 10 | mouseleave |    A    |                                         |
		++----+------------+---------------------------------------------------+

		<p class="note">
		The EVENT{mouseover}/EVENT{mouseout} events are only fired once, while
		EVENT{mouseenter}/EVENT{mouseleave} events are fired three times (once
		to each element).
		</p>

		The following is the typical sequence of events when a button associated
		with a pointing device (e.g., a mouse button or trackpad) is pressed and
		released over an element:

		++----+------------+---------------------------------------------------+
		=|  # | Event Type | Notes                                             |
		 +----+------------+---------------------------------------------------+
		+|  1 | mousedown  |                                                   |
		+|  2 | mousemove  | OPTIONAL, multiple events, some limits            |
		+|  3 | mouseup    |                                                   |
		+|  4 | click      |                                                   |
		+|  5 | mousemove  | OPTIONAL, multiple events, some limits            |
		+|  6 | mousedown  |                                                   |
		+|  7 | mousemove  | OPTIONAL, multiple events, some limits            |
		+|  8 | mouseup    |                                                   |
		+|  9 | click      |                                                   |
		+| 10 | dblclick   |                                                   |
		++----+------------+---------------------------------------------------+

		<p class="note">
		The lag time, degree, distance, and number of EVENT{mousemove} events
		allowed between the EVENT{mousedown} and EVENT{mouseup} events while
		still firing a EVENT{click} or EVENT{dblclick} event will be
		implementation-, device-, and platform-specific. This tolerance can aid
		users that have physical disabilities like unsteady hands when these
		users interact with a pointing device.
		</p>

		Each implementation will determine the appropriate <a>hysteresis</a>
		tolerance, but in general SHOULD fire EVENT{click} and EVENT{dblclick}
		events when the event target of the associated EVENT{mousedown} and
		EVENT{mouseup} events is the same element with no EVENT{mouseout} or
		EVENT{mouseleave} events intervening, and SHOULD fire EVENT{click} and
		EVENT{dblclick} events on the nearest common inclusive ancestor when the
		associated EVENT{mousedown} and EVENT{mouseup} event targets are
		different.

		<p class="example">
		If a EVENT{mousedown} event was targeted at an HTML document's <a>body
		element</a>, and the corresponding EVENT{mouseup} event was targeted at
		the <a>root element</a>, then the EVENT{click} event will be dispatched
		to the <a>root element</a>, since it is the nearest common inclusive
		ancestor.
		</p>

		If the <a>event target</a> (e.g. the target element) is removed from the
		DOM during the mouse events sequence, the remaining events of the
		sequence MUST NOT be fired on that element.

		<p class="example">
		If the target element is removed from the DOM as the result of a
		EVENT{mousedown} event, no events for that element will be dispatched
		for EVENT{mouseup}, EVENT{click}, or EVENT{dblclick}, nor any default
		activation events. However, the EVENT{mouseup} event will still be
		dispatched on the element that is exposed to the mouse after the removal
		of the initial target element. Similarly, if the target element is
		removed from the DOM during the dispatch of a EVENT{mouseup} event, the
		EVENT{click} and subsequent events will not be dispatched.
		</p>

	<h4 id="events-mouse-types">Mouse Event Types</h4>

		The Mouse event types are listed below. In the case of nested elements,
		mouse event types are always targeted at the most deeply nested element.
		Ancestors of the targeted element MAY use bubbling to obtain
		notification of mouse events which occur within its descendent elements.

		<h5 id="event-type-click"><dfn>click</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>click</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{MouseEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>Varies</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>topmost event target</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								indicates the <a href="#current-click-count">current click count</a>;
								the attribute value MUST be <code>1</code> when the user begins this action and increments by <code>1</code> for each click.</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/button}} :
								value based on current button pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
								value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
								<code>null</code></li>
						</ul>
					</td>
				</tr>
			</table>

			The EVENT{click} event type MUST be dispatched on the <a>topmost
			event target</a> indicated by the pointer, when the user presses
			down and releases the primary pointer button, or otherwise activates
			the pointer in a manner that simulates such an action. The actuation
			method of the mouse button depends upon the pointer device and the
			environment configuration, e.g., it MAY depend on the screen
			location or the delay between the press and release of the pointing
			device button.

			The EVENT{click} event should only be fired for the primary pointer
			button (i.e., when {{MouseEvent/button}} value is <code>0</code>,
			{{MouseEvent/buttons}} value is <code>1</code>). Secondary buttons
			(like the middle or right button on a standard mouse) MUST NOT fire
			EVENT{click} events.

			The EVENT{click} event MAY be preceded by the EVENT{mousedown} and
			EVENT{mouseup} events on the same element, disregarding changes
			between other node types (e.g., text nodes).  Depending upon the
			environment configuration, the EVENT{click} event MAY be dispatched
			if one or more of the event types EVENT{mouseover},
			EVENT{mousemove}, and EVENT{mouseout} occur between the press and
			release of the pointing device button.  The EVENT{click} event MAY
			also be followed by the EVENT{dblclick} event.

			<p class="example">
			If a user mouses down on a text node child of a
			<code>&lt;p&gt;</code> element which has been styled with a large
			line-height, shifts the mouse slightly such that it is no longer
			over an area containing text but is still within the containing
			block of that <code>&lt;p&gt;</code> element (i.e., the pointer is
			between lines of the same text block, but not over the text node per
			se), then subsequently mouses up, this will likely still trigger a
			EVENT{click} event (if it falls within the normal temporal
			<a>hysteresis</a> for a EVENT{click}), since the user has stayed
			within the scope of the same element. Note that user-agent-generated
			mouse events are not dispatched on text nodes.
			</p>

			In addition to being associated with pointer devices, the
			EVENT{click} event type MUST be dispatched as part of an element
			activation, as described in [[#event-flow-activation]].

			<p class="note">
			For maximum accessibility, content authors are encouraged to use the
			EVENT{click} event type when defining activation behavior for custom
			controls, rather than other pointing-device event types such as
			EVENT{mousedown} or EVENT{mouseup}, which are more device-specific.
			Though the EVENT{click} event type has its origins in pointer
			devices (e.g., a mouse), subsequent implementation enhancements have
			extended it beyond that association, and it can be considered a
			device-independent event type for element activation.
			</p>

			The <a>default action</a> of the EVENT{click} event type varies
			based on the <a>event target</a> of the event and the value of the
			{{MouseEvent/button}} or {{MouseEvent/buttons}} attributes. Typical
			<a>default actions</a> of the EVENT{click} event type are as follows:

			*	If the <a>event target</a> has associated activation behavior,
				the <a>default action</a> MUST be to execute that activation
				behavior (see [[#event-flow-activation]]).

			*	If the <a>event target</a> is focusable, the <a>default
				action</a> MUST be to give that element document focus.

		<h5 id="event-type-dblclick"><dfn>dblclick</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>dblclick</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{MouseEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>topmost event target</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								indicates the <a href="#current-click-count">current click count</a></li>
							<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/button}} :
								value based on current button pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
								value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
								<code>null</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when the primary button
			of a pointing device is clicked twice over an element. The
			definition of a double click depends on the environment
			configuration, except that the event target MUST be the same between
			EVENT{mousedown}, EVENT{mouseup}, and EVENT{dblclick}. This event
			type MUST be dispatched after the event type EVENT{click} if a click
			and double click occur simultaneously, and after the event type
			EVENT{mouseup} otherwise.

			As with the EVENT{click} event, the EVENT{dblclick} event should
			only be fired for the primary pointer button. Secondary buttons MUST
			NOT fire EVENT{dblclick} events.

			<p class="note">
			Canceling the EVENT{click} event does not affect the firing of a
			EVENT{dblclick} event.
			</p>

			As with the EVENT{click} event type, the <a>default action</a> of
			the EVENT{dblclick} event type varies based on the <a>event
			target</a> of the event and the value of the {{MouseEvent/button}}
			or {{MouseEvent/buttons}} attributes. Normally, the typical
			<a>default actions</a> of the EVENT{dblclick} event type match those
			of the EVENT{click} event type, with the following additional
			behavior:

			*	If the <a>event target</a> is selectable, the <a>default
				action</a> MUST be to select part or all of the selectable
				content. Subsequent clicks MAY select additional selectable
				portions of that content.

		<h5 id="event-type-mousedown"><dfn>mousedown</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>mousedown</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{MouseEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>Varies: Start a drag/drop operation; start a text selection; start a scroll/pan interaction (in combination with the middle mouse button, if supported)</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>topmost event target</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								indicates the <a href="#current-click-count">current click count</a> incremented by one. For example, if no click happened
								before the EVENT{mousedown}, {{UIEvent/detail}}
								will contain the value <code>1</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/button}} :
								value based on current button pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
								value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
								<code>null</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a pointing device
			button is pressed over an element.

			<p class="note">
			Many implementations use the EVENT{mousedown} event to begin a
			variety of contextually dependent <a>default actions</a>. These
			default actions can be prevented if this event is canceled. Some of
			these default actions could include: beginning a drag/drop
			interaction with an image or link, starting text selection, etc.
			Additionally, some implementations provide a mouse-driven panning
			feature that is activated when the middle mouse button is pressed at
			the time the EVENT{mousedown} event is dispatched.
			</p>

		<h5 id="event-type-mouseenter"><dfn>mouseenter</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>mouseenter</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{MouseEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>topmost event target</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/button}} :
								<code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
								value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
								indicates the <a>event target</a> a pointing device is exiting, if any.</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a pointing device
			is moved onto the boundaries of an element or one of its descendent
			elements.  This event type is similar to EVENT{mouseover}, but
			differs in that it does not bubble, and MUST NOT be dispatched when
			the pointer device moves from an element onto the boundaries of one
			of its descendent elements.

			<p class="note">
			There are similarities between this event type and the CSS
			<a href="http://www.w3.org/TR/CSS2/selector.html#dynamic-pseudo-classes"
			title="Selectors"><code>:hover</code> pseudo-class</a> [[CSS2]].
			See also the EVENT{mouseleave} event type.
			</p>

		<h5 id="event-type-mouseleave"><dfn>mouseleave</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>mouseleave</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{MouseEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>topmost event target</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/button}} :
								<code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
								value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
								indicates the <a>event target</a> a pointing device is entering, if any.</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a pointing device
			is moved off of the boundaries of an element and all of its
			descendent elements.  This event type is similar to EVENT{mouseout},
			but differs in that does not bubble, and that it MUST NOT be
			dispatched until the pointing device has left the boundaries of the
			element and the boundaries of all of its children.

			<p class="note">
			There are similarities between this event type and the CSS
			<a href="http://www.w3.org/TR/CSS2/selector.html#dynamic-pseudo-classes"
			title="Selectors"><code>:hover</code> pseudo-class</a> [[CSS2]].
			See also the EVENT{mouseenter} event type.
			</p>

		<h5 id="event-type-mousemove"><dfn>mousemove</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>mousemove</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{MouseEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>topmost event target</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/button}} :
								<code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
								value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
								<code>null</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a pointing device
			is moved while it is over an element.  The frequency rate of events
			while the pointing device is moved is implementation-, device-, and
			platform-specific, but multiple consecutive EVENT{mousemove} events
			SHOULD be fired for sustained pointer-device movement, rather than a
			single event for each instance of mouse movement.  Implementations
			are encouraged to determine the optimal frequency rate to balance
			responsiveness with performance.

			<p class="note">
			In some implementation environments, such as a browser,
			EVENT{mousemove} events can continue to fire if the user began a
			drag operation (e.g., a mouse button is pressed) and the pointing
			device has left the boundary of the user agent.
			</p>

			<p class="note" id="mousemove-now-cancelable">
			This event was formerly specified to be non-cancelable in DOM Level
			2 Events [[!DOM-Level-2-Events]], but was changed to reflect existing
			interoperability between user agents.
			</p>

		<h5 id="event-type-mouseout"><dfn>mouseout</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>mouseout</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{MouseEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>topmost event target</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/button}} :
								<code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
								value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
								indicates the <a>event target</a> a pointing device is entering, if any.</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a pointing device
			is moved off of the boundaries of an element.  This event type is
			similar to EVENT{mouseleave}, but differs in that does bubble, and
			that it MUST be dispatched when the pointer device moves from an
			element onto the boundaries of one of its descendent elements.

			<p class="note">
			See also the EVENT{mouseover} event type.
			</p>

		<h5 id="event-type-mouseover"><dfn>mouseover</dfn></h5>

			<table class="event-definition">
				<tbody>
					<tr>
						<th>Type</th>
						<td><strong><code>mouseover</code></strong></td>
					</tr>
					<tr>
						<th>Interface</th>
						<td>{{MouseEvent}}</td>
					</tr>
					<tr>
						<th>Sync / Async</th>
						<td>Sync</td>
					</tr>
					<tr>
						<th>Bubbles</th>
						<td>Yes</td>
					</tr>
					<tr>
						<th>Trusted Targets</th>
						<td><code>Element</code></td>
					</tr>
					<tr>
						<th>Cancelable</th>
						<td>Yes</td>
					</tr>
					<tr>
						<th>Composed</th>
						<td>Yes</td>
					</tr>
					<tr>
						<th>Default action</th>
						<td>None</td>
					</tr>
					<tr>
						<th>Context<br/>(trusted events)</th>
						<td>
							<ul>
								<li>{{Event}}.{{Event/target}} :
									<a>topmost event target</a></li>
								<li>{{UIEvent}}.{{UIEvent/view}} :
									<a><code>Window</code></a></li>
								<li>{{UIEvent}}.{{UIEvent/detail}} :
									<code>0</code></li>
								<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
									value based on the pointer position on the screen</li>
								<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
									value based on the pointer position on the screen</li>
								<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
									value based on the pointer position within the viewport</li>
								<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
									value based on the pointer position within the viewport</li>
								<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
									<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
								<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
									<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
								<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
									<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
								<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
									<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
								<li>{{MouseEvent}}.{{MouseEvent/button}} :
									<code>0</code></li>
								<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
									value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
								<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
									indicates the <a>event target</a> a pointing device is exiting, if any.</li>
							</ul>
						</td>
					</tr>
				</tbody>
			</table>

			A <a>user agent</a> MUST dispatch this event when a pointing device
			is moved onto the boundaries of an element.  This event type is
			similar to EVENT{mouseenter}, but differs in that it bubbles, and
			that it MUST be dispatched when the pointer device moves onto the
			boundaries of an element whose ancestor element is the <a>event
			target</a> for the same event listener instance.

			<p class="note">
			See also the EVENT{mouseout} event type.
			</p>

		<h5 id="event-type-mouseup"><dfn>mouseup</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>mouseup</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{MouseEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>Invoke a context menu (in combination with the right mouse button, if supported)</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>topmost event target</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								indicates the <a href="#current-click-count">current click count</a> incremented by one.</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
								value based on the pointer position on the screen</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
								value based on the pointer position within the viewport</li>
							<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/button}} :
								value based on current button pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
								value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
								<code>null</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a pointing device
			button is released over an element.

			<p class="note">
			Many implementations will invoke a context menu as the default
			action of this event if the right mouse button is being released.
			</p>

			<p class="note">
			In some implementation environments, such as a browser, a
			EVENT{mouseup} event can be dispatched even if the pointing device
			has left the boundary of the user agent, e.g., if the user began a
			drag operation with a mouse button pressed.
			</p>

<h3 id="events-wheelevents">Wheel Events</h3>

	Wheels are devices that can be rotated in one or more spatial dimensions, and which can be associated with a pointer device. The coordinate system depends on the
	environment configuration.

	<p class="example">
	The user's environment might be configured to associate vertical scrolling
	with rotation along the y-axis, horizontal scrolling with rotation along the
	x-axis, and zooming with rotation along the z-axis.
	</p>

	The deltaX, deltaY, and deltaZ attributes of {{WheelEvent}} objects indicate
	a measurement along their respective axes in units of pixels, lines, or
	pages. The reported measurements are provided after an environment-specific
	algorithm translates the actual rotation/movement of the wheel device into
	the appropriate values and units.

	<p class="note">
	A user's environment settings can be customized to interpret actual rotation/movement
	of a wheel device in different ways.
	One movement of a common <q>dented</q> mouse wheel can produce a measurement of 162 pixels
	(162 is just an example value, actual values can depend on the current screen
	dimensions of the user-agent).
	But a user can change their default environment settings to speed-up their mouse wheel,
	increasing this number.
	Furthermore, some mouse wheel software can support acceleration (the faster the wheel
	is rotated/moved, the greater the <a>delta</a> of each measurement) or even sub-pixel <a>rotation</a>
	measurements.
	Because of this, authors can not assume a given <a>rotation</a> amount in one user agent will
	produce the same <a>delta</a> value in all user agents.
	</p>

	The sign (positive or negative) of the values of the deltaX, deltaY, and deltaZ attributes
	MUST be consistent between multiple dispatches of the
	EVENT{wheel} event while the
	motion of the actual wheel device is rotating/moving in the same direction.
	If a user agent scrolls as the default action of the
	EVENT{wheel} event then the sign
	of the <a>delta</a> SHOULD be given by a right-hand coordinate system where positive X,
	Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest
	depth (away from the user) of the document, respectively.

	<p class="note">
	Individual user agents can (depending on their environment and hardware configuration)
	interpret the same physical user interaction on the wheel differently.
	For example, a vertical swipe on the edge of a trackpad from top to bottom can be
	interpreted as a wheel action intended to either scroll the
	page down or to pan the page up (i.e., resulting in either a positive or negative
	deltaY value respectively).
	</p>

	<h4 id="interface-wheelevent">Interface WheelEvent</h4>

		<p class="intro-dom">Introduced in this specification</p>

		The {{WheelEvent}} interface provides specific contextual information
		associated with EVENT{wheel} events.

		To create an instance of the {{WheelEvent}} interface, use the {{WheelEvent}} constructor,
		passing an optional {{WheelEventInit}} dictionary.

		<pre class="idl">
		[Constructor(DOMString type, optional WheelEventInit eventInitDict)]
		interface WheelEvent : MouseEvent {
			// DeltaModeCode
			const unsigned long DOM_DELTA_PIXEL = 0x00;
			const unsigned long DOM_DELTA_LINE	= 0x01;
			const unsigned long DOM_DELTA_PAGE	= 0x02;

			readonly attribute double deltaX;
			readonly attribute double deltaY;
			readonly attribute double deltaZ;
			readonly attribute unsigned long deltaMode;
		};
		</pre>

		<dl>
			<dt><code>WheelEvent . DOM_DELTA_PIXEL</code></dt>
			<dd>
				The units of measurement for the <a>delta</a> MUST be pixels.
				This is the most typical case in most operating system and
				implementation configurations.
			</dd>

			<dt><code>WheelEvent . DOM_DELTA_LINE</code></dt>
			<dd>
				The units of measurement for the <a>delta</a> MUST be individual
				lines of text.  This is the case for many form controls.
			</dd>

			<dt><code>WheelEvent . DOM_DELTA_PAGE</code></dt>
			<dd>
				The units of measurement for the <a>delta</a> MUST be pages,
				either defined as a single screen or as a demarcated page.
			</dd>

			<dt><code>WheelEvent . deltaX</code></dt>
			<dd>
				In user agents where the default action of the EVENT{wheel}
				event is to scroll, the value MUST be the measurement along the
				x-axis (in pixels, lines, or pages) to be scrolled in the case
				where the event is not cancelled. Otherwise, this is an
				implementation-specific measurement (in pixels, lines, or pages)
				of the movement of a wheel device around the x-axis.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0.0</code>.
			</dd>

			<dt><code>WheelEvent . deltaY</code></dt>
			<dd>
				In user agents where the default action of the EVENT{wheel}
				event is to scroll, the value MUST be the measurement along the
				y-axis (in pixels, lines, or pages) to be scrolled in the case
				where the event is not cancelled. Otherwise, this is an
				implementation-specific measurement (in pixels, lines, or pages)
				of the movement of a wheel device around the y-axis.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0.0</code>.
			</dd>

			<dt><code>WheelEvent . deltaZ</code></dt>
			<dd>
				In user agents where the default action of the EVENT{wheel}
				event is to scroll, the value MUST be the measurement along the
				z-axis (in pixels, lines, or pages) to be scrolled in the case
				where the event is not cancelled. Otherwise, this is an
				implementation-specific measurement (in pixels, lines, or pages)
				of the movement of a wheel device around the z-axis.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0.0</code>.
			</dd>

			<dt><code>WheelEvent . deltaMode</code></dt>
			<dd>
				The <code>deltaMode</code> attribute contains an indication of
				the units of measurement for the <a>delta</a> values. The
				default value is {{WheelEvent/DOM_DELTA_PIXEL}} (pixels).

				This attribute MUST be set to one of the DOM_DELTA constants to
				indicate the units of measurement for the <a>delta</a> values.
				The precise measurement is specific to device, operating system,
				and application configurations.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0</code>.
			</dd>
		</dl>

		<pre class="idl">
		dictionary WheelEventInit : MouseEventInit {
			double deltaX = 0.0;
			double deltaY = 0.0;
			double deltaZ = 0.0;
			unsigned long deltaMode = 0;
		};
		</pre>

		<dl>
			<dt><code>WheelEventInit . deltaX</code></dt>
			<dd>See <code>deltaZ</code> attribute.</dd>

			<dt><code>WheelEventInit . deltaY</code></dt>
			<dd>See <code>deltaZ</code> attribute.</dd>

			<dt><code>WheelEventInit . deltaZ</code></dt>
			<dd>
				Initializes the <code>deltaZ</code> attribute of the WheelEvent
				object. Relative positive values for this attribute (as well as
				the <code>deltaX</code> and <code>deltaY</code> attributes) are
				given by a right-hand coordinate system where the X, Y, and Z
				axes are directed towards the right-most edge, bottom-most edge,
				and farthest depth (away from the user) of the document,
				respectively. Negative relative values are in the respective
				opposite directions.
			</dd>

			<dt><code>WheelEventInit . deltaMode</code></dt>
			<dd>
				Initializes the <code>deltaMode</code> attribute on the
				WheelEvent object to the enumerated values 0, 1, or 2, which
				represent the amount of pixels scrolled
				({{WheelEvent/DOM_DELTA_PIXEL}}), lines scrolled
				({{WheelEvent/DOM_DELTA_LINE}}), or pages scrolled
				({{WheelEvent/DOM_DELTA_PAGE}}) if the <a>rotation</a> of the
				wheel would have resulted in scrolling.
			</dd>
		</dl>

	<h4 id="events-wheel-types">Wheel Event Types</h4>

		<h5 id="event-type-wheel"><dfn>wheel</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>wheel</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{WheelEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Async</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>Scroll (or zoom) the document</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>topmost event target</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/screenX}} :
								if the wheel is associated with a pointing device, the value based on the pointer position on the screen, otherwise <code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/screenY}} :
								if the wheel is associated with a pointing device, the value based
								on the pointer position on the screen, otherwise <code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/clientX}} :
								if the wheel is associated with a pointing device, the value based
								on the pointer position within the viewport, otherwise <code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/clientY}} :
								if the wheel is associated with a pointing device, the value
								based on the pointer position within the viewport, otherwise <code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt}
								modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/button}} :
								if wheel is associated with a pointing device, value based on current button pressed, otherwise <code>0</code></li>
							<li>{{MouseEvent}}.{{MouseEvent/buttons}} :
								if wheel is associated with a pointing device, value based on all buttons current depressed, <code>0</code> if no buttons pressed</li>
							<li>{{MouseEvent}}.{{MouseEvent/relatedTarget}} :
								indicates the <a>event target</a> the pointing device is pointing at, if any.</li>
							<li>{{WheelEvent}}.{{WheelEvent/deltaX}} :
								expected amount that the page will scroll along the x-axis according
								to the deltaMode units; or an implemenation-specific value of movement of a wheel around the x-axis</li>
							<li>{{WheelEvent}}.{{WheelEvent/deltaY}} :
								expected amount that the page will scroll along the y-axis according
								to the deltaMode units; or an implemenation-specific value of movement of a wheel around the y-axis</li>
							<li>{{WheelEvent}}.{{WheelEvent/deltaZ}} :
								expected amount that the page will scroll along the z-axis according
								to the deltaMode units; or an implemenation-specific value of movement of a wheel around the z-axis</li>
							<li>{{WheelEvent}}.{{WheelEvent/deltaMode}} :
								unit indicator (pixels, lines, or pages) for the deltaX, deltaY, and deltaZ attributes</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a mouse wheel has
			been rotated around any axis, or when an equivalent input device
			(such as a mouse-ball, certain tablets or touchpads, etc.) has
			emulated such an action. Depending on the platform and input device,
			diagonal wheel <a>deltas</a> MAY be delivered either as a single
			EVENT{wheel} event with multiple non-zero axes or as separate
			EVENT{wheel} events for each non-zero axis.

			The typical <a>default action</a> of the EVENT{wheel} event type is
			to scroll (or in some cases, zoom) the document by the indicated
			amount.  If this event is canceled, the implementation MUST NOT
			scroll or zoom the document (or perform whatever other
			implementation-specific default action is associated with this event
			type).

			<p class="note">
			In some <a>user agents</a>, or with some input devices, the speed
			that the wheel has been turned can affect the <a>delta</a> values,
			with a faster speed producing a higher <a>delta</a> value.
			</p>

<h3 id="events-inputevents">Input Events</h3>

	Input events are sent as notifications whenever the DOM is being updated.

	<h4 id="interface-inputevent">Interface InputEvent</h4>

		<p class="intro-dom">Introduced in DOM Level 3</p>

		<pre class="idl">
		[Constructor(DOMString type, optional InputEventInit eventInitDict)]
		interface InputEvent : UIEvent {
			readonly attribute DOMString data;
			readonly attribute boolean isComposing;
		};
		</pre>

		<dl>
			<dt><code>InputEvent . data</code></dt>
			<dd>
				<code>data</code> holds the value of the characters generated by
				an input method. This MAY be a single Unicode character or a
				non-empty sequence of Unicode characters [[Unicode]]. Characters
				SHOULD be normalized as defined by the Unicode normalization
				form <em>NFC</em>, defined in [[UAX15]].
				This attribute MAY contain the <a>empty string</a>.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>""</code> (the empty string).
			</dd>

			<dt><code>InputEvent . isComposing</code></dt>
			<dd>
				<code>true</code> if the input event occurs as part of a
				composition session, i.e., after a EVENT{compositionstart} event
				and before the corresponding EVENT{compositionend} event.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>false</code>.
			</dd>
		</dl>

		<pre class="idl">
		dictionary InputEventInit : UIEventInit {
			DOMString data = "";
			boolean isComposing = false;
		};
		</pre>

		<dl>
			<dt><code>InputEventInit . data</code></dt>
			<dd>
				Initializes the <code>data</code> attribute of the InputEvent object.
			</dd>

			<dt><code>InputEventInit . isComposing</code></dt>
			<dd>
				Initializes the <code>isComposing</code> attribute of the InputEvent object.
			</dd>
		</dl>

	<h4 id="events-inputevent-event-order">Input Event Order</h4>

		The input events defined in this specification MUST occur in a set order
		relative to one another.

		++---+-------------+---------------------------------------------------+
		=| # | Event Type  | Notes                                             |
		 +---+-------------+---------------------------------------------------+
		+| 1 | beforeinput |                                                   |
		+|   |             | <em>DOM element is updated</em>                   |
		+| 2 | input       |                                                   |
		++---+-------------+---------------------------------------------------+

	<h4 id="events-input-types">Input Event Types</h4>

		<h5 id="event-type-beforeinput"><dfn>beforeinput</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>beforeinput</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{InputEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code> (specifically: control types such as <code>HTMLInputElement</code>, etc.) or any <code>Element</code> with
						<code>contenteditable</code> attribute enabled.</td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>Update the DOM element</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>event target</a> that is about to be updated</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{InputEvent}}.{{InputEvent/data}} :
								the string containing the data that will be added to the element,
								which MAY be the <a>empty string</a> if the content has been deleted</li>
							<li>{{InputEvent}}.{{InputEvent/isComposing}} :
								<code>true</code> if this event is dispatched during a <a href="#keys-dead">dead key</a> sequence or while an
								<a>input method editor</a> is active (such that
								<a href="#events-compositionevents">composition events</a> are being dispatched); <code>false</code> otherwise.</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when the DOM is about
			to be updated.

		<h5 id="event-type-input"><dfn>input</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>input</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{InputEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code> (specifically: control types such as <code>HTMLInputElement</code>, etc.) or any <code>Element</code> with
						<code>contenteditable</code> attribute enabled.</td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								<a>event target</a> that was just updated</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{InputEvent}}.{{InputEvent/data}} :
								the string containing the data that was added to the element,
								which MAY be the <a>empty string</a> if the content has been deleted</li>
							<li>{{InputEvent}}.{{InputEvent/isComposing}} :
								<code>true</code> if this event is dispatched during a <a href="#keys-dead">dead key</a> sequence or while an
								<a>input method editor</a> is active (such that
								<a href="#events-compositionevents">composition events</a> are being dispatched); <code>false</code> otherwise.</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event immediately after the
			DOM has been updated.


<h3 id="events-keyboardevents">Keyboard Events</h3>

	Keyboard events are device dependent, i.e., they rely on the capabilities of
	the input devices and how they are mapped in the operating systems. Refer to
	<a href="#keys">Keyboard events and key values</a> for more details,
	including examples on how Keyboard Events are used in combination with
	Composition Events. Depending on the character generation device, keyboard
	events might not be generated.

	<p class="note">
	Keyboard events are only one modality of providing textual input. For
	editing scenarios, consider also using the {{InputEvent}} as an alternate to
	(or in addition to) keyboard events.
	</p>

	<h4 id="interface-keyboardevent">Interface KeyboardEvent</h4>

		<p class="intro-dom">Introduced in this specification</p>

		The {{KeyboardEvent}} interface provides specific contextual information
		associated with keyboard devices. Each keyboard event references a key
		using a value. Keyboard events are commonly directed at the element that
		has the focus.

		The {{KeyboardEvent}} interface provides convenient attributes for some
		common modifiers keys: {{KeyboardEvent/ctrlKey}},
		{{KeyboardEvent/shiftKey}}, {{KeyboardEvent/altKey}},
		{{KeyboardEvent/metaKey}}. These attributes are equivalent to using the
		method {{KeyboardEvent/getModifierState()}} with KEYCAP{Control},
		KEYCAP{Shift}, KEYCAP{Alt}, or KEYCAP{Meta} respectively.

		To create an instance of the {{KeyboardEvent}} interface, use the
		{{KeyboardEvent}} constructor, passing an optional
		{{KeyboardEventInit}} dictionary.

		<pre class="idl" data-highlight="webidl">
		[Constructor(DOMString type, optional KeyboardEventInit eventInitDict)]
		interface KeyboardEvent : UIEvent {
			// KeyLocationCode
			const unsigned long DOM_KEY_LOCATION_STANDARD = 0x00;
			const unsigned long DOM_KEY_LOCATION_LEFT = 0x01;
			const unsigned long DOM_KEY_LOCATION_RIGHT = 0x02;
			const unsigned long DOM_KEY_LOCATION_NUMPAD = 0x03;

			readonly attribute DOMString key;
			readonly attribute DOMString code;
			readonly attribute unsigned long location;

			readonly attribute boolean ctrlKey;
			readonly attribute boolean shiftKey;
			readonly attribute boolean altKey;
			readonly attribute boolean metaKey;

			readonly attribute boolean repeat;
			readonly attribute boolean isComposing;

			boolean getModifierState(DOMString keyArg);
		};
		</pre>

		<dl>
			<dt><code>KeyboardEvent . DOM_KEY_LOCATION_STANDARD</code></dt>
			<dd>
				The key activation MUST NOT be distinguished as the left or
				right version of the key, and (other than the KEYCAP{NumLock}
				key) did not originate from the numeric keypad (or did not
				originate with a virtual key corresponding to the numeric
				keypad).

				<p class="example">
				The KEYCAP{Q} key on a PC 101 Key US keyboard.<br/>
				The KEYCAP{NumLock} key on a PC 101 Key US keyboard.<br/>
				The KEYCAP{1} key on a PC 101 Key US keyboard located in the
				main section of the keyboard.
				</p>
			</dd>

			<dt><code>KeyboardEvent . DOM_KEY_LOCATION_LEFT</code></dt>
			<dd>
				The key activated originated from the left key location (when
				there is more than one possible location for this key).

				<p class="example">
				The left KEYCAP{Control} key on a PC 101 Key US keyboard.
				</p>
			</dd>

			<dt><code>KeyboardEvent . DOM_KEY_LOCATION_RIGHT</code></dt>
			<dd>
				The key activation originated from the right key location (when
				there is more than one possible location for this key).

				<p class="example">
				The right KEYCAP{Shift} key on a PC 101 Key US keyboard.
				</p>
			</dd>

			<dt><code>KeyboardEvent . DOM_KEY_LOCATION_NUMPAD</code></dt>
			<dd>
				The key activation originated on the numeric keypad or with a
				virtual key corresponding to the numeric keypad (when there is
				more than one possible location for this key). Note that the
				KEYCAP{NumLock} key should always be encoded with a
				{{KeyboardEvent/location}} of
				{{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}}.

				<p class="example">
				The KEYCAP{1} key on a PC 101 Key US keyboard located on the
				numeric pad.
				</p>
			</dd>

			<dt><code>KeyboardEvent . key</code></dt>
			<dd>
				<code>key</code> holds a [=key attribute value=] corresponding to
				the key pressed.
				
				<p class="note">
				The <code>key</code> attribute is not related to the legacy
				<code>keyCode</code> attribute and does not have the same set of
				values.
				</p>

				The <a>un-initialized value</a> of this attribute MUST be
				<code>""</code> (the empty string).
			</dd>

			<dt><code>KeyboardEvent . code</code></dt>
			<dd>
				<code>code</code> holds a string that identifies the physical
				key being pressed. The value is not affected by the current
				keyboard layout or modifier state, so a particular key will
				always return the same value.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>""</code> (the empty string).
			</dd>

			<dt><code>KeyboardEvent . location</code></dt>
			<dd>
				The {{KeyboardEvent/location}} attribute contains an indication
				of the logical location of the key on the device.

				This attribute MUST be set to one of the DOM_KEY_LOCATION
				constants to indicate the location of a key on the device.

				If a <a>user agent</a> allows keys to be remapped, then the
				{{KeyboardEvent/location}} value for a remapped key MUST be set
				to a value which is appropriate for the new key. For example, if
				the CODE{ControlLeft} key is mapped to the CODE{KeyQ} key, then
				the {{KeyboardEvent/location}} attribute MUST be set to
				{{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}}. Conversely, if the
				CODE{KeyQ} key is remapped to one of the KEYCAP{Control} keys,
				then the {{KeyboardEvent/location}} attribute MUST be set to
				either {{KeyboardEvent/DOM_KEY_LOCATION_LEFT}} or
				{{KeyboardEvent/DOM_KEY_LOCATION_RIGHT}}.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>0</code>.
			</dd>

			<dt><code>KeyboardEvent . ctrlKey</code></dt>
			<dd>
				<code>true</code> if the KEYCAP{Control} (control) key modifier
				was active.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>false</code>.
			</dd>

			<dt><code>KeyboardEvent . shiftKey</code></dt>
			<dd>
				<code>true</code> if the shift (KEYCAP{Shift}) key modifier was
				active.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>false</code>.
			</dd>

			<dt><code>KeyboardEvent . altKey</code></dt>
			<dd>
				<code>true</code> if the KEYCAP{Alt} (alternative) (or
				GLYPH{Option}) key modifier was active.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>false</code>.
			</dd>

			<dt><code>KeyboardEvent . metaKey</code></dt>
			<dd>
				<code>true</code> if the meta (KEYCAP{Meta}) key modifier was
				active.

				<p class="note">
				The GLYPH{Command} (GLYPH{&#x2318;}) key modifier on Macintosh
				systems is represented using this key modifier.
				</p>

				The <a>un-initialized value</a> of this attribute MUST be
				<code>false</code>.
			</dd>

			<dt><code>KeyboardEvent . repeat</code></dt>
			<dd>
				<code>true</code> if the key has been pressed in a sustained
				manner.  Holding down a key MUST result in the repeating the
				events EVENT{keydown}, EVENT{beforeinput}, EVENT{input} in this
				order, at a rate determined by the system configuration. For
				mobile devices which have <em>long-key-press</em> behavior, the
				first key event with a {{KeyboardEvent/repeat}} attribute value
				of <code>true</code> MUST serve as an indication of a
				<em>long-key-press</em>. The length of time that the key MUST be
				pressed in order to begin repeating is configuration-dependent.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>false</code>.
			</dd>

			<dt><code>KeyboardEvent . isComposing</code></dt>
			<dd>
				<code>true</code> if the key event occurs as part of a
				composition session, i.e., after a EVENT{compositionstart} event
				and before the corresponding EVENT{compositionend} event.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>false</code>.
			</dd>

			<dt><code>KeyboardEvent . getModifierState()</code></dt>
			<dd>
				Queries the state of a modifier using a key value. See <a
				href="#keys-modifiers">Modifier keys</a> for a list of valid
				(case-sensitive) arguments to this method.

				<dl class="parameters">
					<dt>DOMString keyArg</dt>
					<dd>
						A modifier key value.  Valid modifier keys are defined
						in the <a
						href="DOM3Events-key.html#keys-modifier">Modifier
						Keys</a> table in [[UIEvents-Key]].

						Returns <code>true</code> if it is a modifier key and
						the modifier is activated, <code>false</code> otherwise.

						<p class="note">
						If an application wishes to distinguish between right
						and left modifiers, this information could be deduced
						using keyboard events and {{KeyboardEvent/location}}.
						</p>
					</dd>
				</dl>
			</dd>
		</dl>

		<pre class="idl">
		dictionary KeyboardEventInit : EventModifierInit {
			DOMString key = "";
			DOMString code = "";
			unsigned long location = 0;
			boolean repeat = false;
			boolean isComposing = false;
		};
		</pre>

		<dl>
			<dt><code>KeyboardEventInit . key</code></dt>
			<dd>
				Initializes the <code>key</code> attribute of the KeyboardEvent
				object to the unicode character string representing the meaning
				of a key after taking into account all keyboard modifiers
				(such as shift-state). This value is the final effective value
				of the key. If the key is not a printable character, then it
				should be one of the key values defined in [[UIEvents-Key]].
			</dd>

			<dt><code>KeyboardEventInit . code</code></dt>
			<dd>
				Initializes the <code>code</code> attribute of the KeyboardEvent
				object to the unicode character string representing the key that
				was pressed, ignoring any keyboard modifications such as
				keyboard layout. This value should be one of the code values
				defined in [UIEvents-Code]].
			</dd>

			<dt><code>KeyboardEventInit . location</code></dt>
			<dd>
				Initializes the {{KeyboardEvent/location}} attribute of the
				KeyboardEvent object to one of the following location numerical
				constants:

				*	{{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}} (numerical value 0)</li>
				*	{{KeyboardEvent/DOM_KEY_LOCATION_LEFT}} (numerical value 1)</li>
				*	{{KeyboardEvent/DOM_KEY_LOCATION_RIGHT}} (numerical value 2)</li>
				*	{{KeyboardEvent/DOM_KEY_LOCATION_NUMPAD}} (numerical value 3)</li>
			</dd>

			<dt><code>KeyboardEventInit . repeat</code></dt>
			<dd>
				Initializes the <code>repeat</code> attribute of the
				KeyboardEvent object. This attribute should be set to
				<code>true</code> if the the current KeyboardEvent is considered
				part of a repeating sequence of similar events caused by the
				long depression of any single key, <code>false</code> otherwise.
			</dd>

			<dt><code>KeyboardEventInit . isComposing</code></dt>
			<dd>
				Initializes the <code>isComposing</code> attribute of the
				KeyboardEvent object. This attribute should be set to
				<code>true</code> if the event being constructed occurs as part
				of a composition sequence, <code>false</code> otherwise.
			</dd>
		</dl>

	<div class="warning">
	Legacy keyboard event implementations include three additional attributes,
	<code>keyCode</code>, <code>charCode</code>, and <code>which</code>. The
	<code>keyCode</code> attribute indicates a numeric value associated with a
	particular key on a computer keyboard, while the <code>charCode</code>
	attribute indicates the <acronym title="American Standard Code for
	Information Interchange">ASCII</acronym> value of the character associated
	with that key (which might be the same as the <code>keyCode</code> value)
	and is applicable only to keys that produce a <a>character value</a>.

	In practice, <code>keyCode</code> and <code>charCode</code> are inconsistent
	across platforms and even the same implementation on different operating
	systems or using different localizations. This specification does not define
	values for either <code>keyCode</code> or <code>charCode</code>, or behavior
	for <code>charCode</code>. In conforming UI Events implementations, content
	authors can instead use {{KeyboardEvent/key}} and {{KeyboardEvent/code}}.

	<em>For more information, see the informative appendix on
	<a href="#legacy-key-attributes">Legacy key attributes</a>.</em>
	</div>

	<p class="note">
	For compatibility with existing content, virtual keyboards, such as software
	keyboards on screen-based input devices, are expected to produce the normal
	range of keyboard events, even though they do not possess physical keys.
	</p>

	<p class="note">
	In some implementations or system configurations, some key events, or their
	values, might be suppressed by the <a>IME</a> in use.
	</p>

	<h4 id="events-keyboard-key-location">Keyboard Event Key Location</h4>

		The {{KeyboardEvent/location}} attribute can be used to disambiguate
		between {{KeyboardEvent/key}} values that can be generated by different
		physical keys on the keyboard, for example, the left and right
		KEYCAP{Shift} key or the physical arrow keys vs. the numpad arrow keys
		(when KEYCAP{NumLock} is off).

		The following table defines the valid {{KeyboardEvent/location}} values
		for the special keys that have more than one location on the keyboard:

		++---------------------------------+----------------------------------------------+
		=| {{KeyboardEvent}} .             | Valid {{KeyboardEvent/location}} values      |
		 | {{KeyboardEvent/key}}           |                                              |
		 +---------------------------------+----------------------------------------------+
		+| KEY{Shift}, KEY{Control},       | {{KeyboardEvent/DOM_KEY_LOCATION_LEFT}},     |
		 | KEY{Alt}, KEY{Meta}             | {{KeyboardEvent/DOM_KEY_LOCATION_RIGHT}}     |
		 +---------------------------------+----------------------------------------------+
		+| KEY{ArrowDown}, KEY{ArrowLeft}, | {{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}}, |
		 | KEY{ArrowRight}, KEY{ArrowUp}   | {{KeyboardEvent/DOM_KEY_LOCATION_NUMPAD}}    |
		 +---------------------------------+----------------------------------------------+
		+| KEY{End}, KEY{Home},            | {{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}}, |
		 | KEY{PageDown}, KEY{PageUp}      | {{KeyboardEvent/DOM_KEY_LOCATION_NUMPAD}}    |
		 +---------------------------------+----------------------------------------------+
		+| KEY_NOLINK{0}, KEY_NOLINK{1},   | {{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}}, |
		 | KEY_NOLINK{2}, KEY_NOLINK{2},   | {{KeyboardEvent/DOM_KEY_LOCATION_NUMPAD}}    |
		 | KEY_NOLINK{4}, KEY_NOLINK{5},   |                                              |
		 | KEY_NOLINK{6}, KEY_NOLINK{7},   |                                              |
		 | KEY_NOLINK{8}, KEY_NOLINK{9},   |                                              |
		 | KEY_NOLINK{.}, KEY{Enter},      |                                              |
		 | KEY_NOLINK{+}, KEY_NOLINK{-},   |                                              |
		 | KEY_NOLINK{*}, KEY_NOLINK{/}    |                                              |
		++---------------------------------+----------------------------------------------+

		For all other keys not listed in this table, the
		{{KeyboardEvent/location}} attribute MUST always be set to
		{{KeyboardEvent/DOM_KEY_LOCATION_STANDARD}}.

	<h4 id="events-keyboard-event-order">Keyboard Event Order</h4>

		The keyboard events defined in this specification occur in a set order
		relative to one another, for any given key:

		++---+-------------+--------------------------------------------------------+
		=| # | Event Type  | Notes                                                  |
		 +---+-------------+--------------------------------------------------------+
		+| 1 | keydown     |                                                        |
		+| 2 | beforeinput | <em>(only for keys which produce a <a>character        |
		 |   |             | value</a>)</em>                                        |
		+|   |             | <em>Any <a>default actions</a> related to this         |
		 |   |             | key, such as inserting a character in to the DOM.</em> |
		+| 3 | input       | <em>(only for keys which have updated the DOM)</em>    |
		+|   |             | <em>Any events as a result of the key being held for a |
		 |   |             | sustained period (see below).</em>                     |
		+| 4 | keyup       |                                                        |
		++---+-------------+--------------------------------------------------------+

		If the key is depressed for a sustained period, the following events MAY
		repeat at an environment-dependent rate: <!-- and the key should seek
		counseling -->

		++---+-------------+---------------------------------------------------+
		=| # | Event Type  | Notes                                             |
		 +---+-------------+---------------------------------------------------+
		+| 1 | keydown     | <em>(with {{KeyboardEvent/repeat}} attribute set  |
		 |   |             | to <code>true</code>)</em>                        |
		+| 2 | beforeinput | <em>(only for keys which produce a <a>character   |
		 |   |             | value</a>)</em>                                   |
		+|   |             | <em>Any <a>default actions</a> related to this    |
		 |   |             | key, such as inserting a character in to the      |
		 |   |             | DOM.</em>                                         |
		+| 3 | input       | <em>(only for keys which have updated the         |
		 |   |             | DOM)</em>                                         |
		++---+-------------+---------------------------------------------------+

		<p class="note">
		Typically, any <a>default actions</a> associated with any particular key
		are completed before the EVENT{keyup} event is dispatched. This might
		delay the EVENT{keyup} event slightly (though this is not likely to be a
		perceptible delay).
		</p>

		The <a>event target</a> of a key event is the currently focused element
		which is processing the keyboard activity. This is often an HTML
		<code>input</code> element or a textual element which is editable, but
		MAY be an element defined by the <a>host language</a> to accept keyboard
		input for non-text purposes, such as the activation of an accelerator
		key or trigger of some other behavior. If no suitable element is in
		focus, the event target will be the HTML <a>body element</a> if
		available, otherwise the <a>root element</a>.

		<p class="note">
		The <a>event target</a> might change between different key events. For
		example, a EVENT{keydown} event for the KEYCAP{Tab} key will likely have
		a different <a>event target</a> than the  EVENT{keyup} event on the same
		keystroke.

	<h4 id="events-keyboard-types">Keyboard Event Types</h4>

		<h5 id="event-type-keydown"><dfn>keydown</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>keydown</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{KeyboardEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>Varies:
						EVENT{beforeinput} and
						EVENT{input} events;
						launch <a>text composition system</a>;
						EVENT{blur} and
						EVENT{focus} events;
						EVENT{keypress} event (if supported);
						<a>activation behavior</a>;
						other event</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								focused element processing the key event or if no element focused, then the
								<a>body element</a> if available, otherwise the
								<a>root element</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/key}} :
								the key value of the key pressed.</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/code}} :
								the code value associated with the key's physical placement on the keyboard.</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/location}} :
								the location of the key on the device.</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/repeat}} :
								<code>true</code> if a key has been depressed long enough to trigger key repetition, otherwise <code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/isComposing}} :
								<code>true</code> if the key event occurs as part of a composition session, otherwise <code>false</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a key is pressed
			down. The EVENT{keydown} event type is device dependent and relies
			on the capabilities of the input devices and how they are mapped in
			the operating system. This event type MUST be generated after the
			<a>key mapping</a>. This event type MUST be dispatched before the
			EVENT{beforeinput}, EVENT{input}, and EVENT{keyup} events associated
			with the same key.

			The default action of the EVENT{keydown} event depends upon the key:

			*	If the key is associated with a character, the default action
				MUST be to dispatch a EVENT{beforeinput} event followed by an
				EVENT{input} event. In the case where the key which is
				associated with multiple characters (such as with a macro or
				certain sequences of dead keys), the default action MUST be to
				dispatch one set of EVENT{beforeinput} / EVENT{input} events for
				each character

			*	If the key is associated with a <a>text composition system</a>,
				the default action MUST be to launch that system

			*	If the key is the KEYCAP{Tab} key, the default action MUST be
				to shift the document focus from the currently focused element
				(if any) to the new focused element, as described in
				<a href="#events-focusevent">Focus Event Types</a>

			*	If the key is the KEYCAP{Enter} or KEYCAP{&nbsp;} key and the
				current focus is on a state-changing element, the default action
				MUST be to dispatch a EVENT{click} event, and a
				EVENT{DOMActivate} event if that event type is supported by the
				<a>user agent</a> (refer to [[#event-flow-activation]] for more
				details)

			If this event is canceled, the associated event types MUST NOT be
			dispatched, and the associated actions MUST NOT be performed.

			<p class="note">
			The EVENT{keydown} and EVENT{keyup} events are traditionally
			associated with detecting any key, not just those which produce a
			<a>character value</a>.
			</p>

		<h5 id="event-type-keyup"><dfn>keyup</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>keyup</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{KeyboardEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								focused element processing the key event or if no element focused, then the
								<a>body element</a> if available, otherwise the
								<a>root element</a></li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/key}} :
								the key value of the key pressed.</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/code}} :
								the code value associated with the key's physical placement on the keyboard.</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/location}} :
								the location of the key on the device.</li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/altKey}} :
								<code>true</code> if KEYCAP{Alt} modifier was active, otherwise <code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/shiftKey}} :
								<code>true</code> if KEYCAP{Shift} modifier was active, otherwise <code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/ctrlKey}} :
								<code>true</code> if KEYCAP{Control} modifier was active, otherwise <code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/metaKey}} :
								<code>true</code> if KEYCAP{Meta} modifier was active, otherwise <code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/repeat}} :
								<code>false</code></li>
							<li>{{KeyboardEvent}}.{{KeyboardEvent/isComposing}} :
								<code>true</code> if the key event occurs as part of a composition session, otherwise <code>false</code></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a key is released.
			The EVENT{keyup} event type is device dependent and relies on the
			capabilities of the input devices and how they are mapped in the
			operating system. This event type MUST be generated after the <a>key
			mapping</a>. This event type MUST be dispatched after the
			EVENT{keydown}, EVENT{beforeinput}, and EVENT{input} events
			associated with the same key.

			<p class="note">
			The EVENT{keydown} and EVENT{keyup} events are traditionally
			associated with detecting any key, not just those which produce a
			<a>character value</a>.
			</p>

<h3 id="events-compositionevents">Composition Events</h3>

	Composition Events provide a means for inputing text in a supplementary or
	alternate manner than by Keyboard Events, in order to allow the use of
	characters that might not be commonly available on keyboard. For example,
	Composition Events might be used to add accents to characters despite their
	absence from standard US keyboards, to build up logograms of many Asian
	languages from their base components or categories, to select word choices
	from a combination of key presses on a mobile device keyboard, or to convert
	voice commands into text using a speech recognition processor. Refer to
	[[#keys]] for examples on how Composition Events are used in combination
	with keyboard events.

	Conceptually, a composition session consists of one EVENT{compositionstart}
	event, one or more EVENT{compositionupdate} events, and one
	EVENT{compositionend} event, with the value of the {{CompositionEvent/data}}
	attribute persisting between each <q>stage</q> of this event chain during
	each session.

	<p class="note"><strong>Note:</strong>
	While a composition session is active, keyboard events can be dispatched to
	the DOM if the keyboard is the input device used with the composition
	session. See the EVENT{compositionstart} event details</a> and
	<a href="#keys-IME">IME section</a> for relevent event ordering.
	</p>

	Not all <a>IME</a> systems or devices expose the necessary data to the DOM,
	so the active composition string (the <q>Reading Window</q> or <q>candidate
	selection menu option</q>) might not be available through this interface, in
	which case the selection MAY be represented by the <a>empty string</a>.

	<h4 id="interface-compositionevent">Interface CompositionEvent</h4>

		<p class="intro-dom">Introduced in this specification</p>

		The {{CompositionEvent}} interface provides specific contextual
		information associated with Composition Events.

		To create an instance of the {{CompositionEvent}} interface,
		use the {{CompositionEvent}} constructor, passing an optional
		{{CompositionEventInit}} dictionary.

		<pre class="idl">
		[Constructor(DOMString type, optional CompositionEventInit eventInitDict)]
		interface CompositionEvent : UIEvent {
			readonly attribute DOMString data;
		};
		</pre>

		<dl>
			<dt><code>CompositionEvent . data</code></dt>
			<dd>
				<code>data</code> holds the value of the characters generated by
				an input method. This MAY be a single Unicode character or a
				non-empty sequence of Unicode characters [[Unicode]]. Characters
				SHOULD be normalized as defined by the Unicode normalization
				form <em>NFC</em>, defined in [[UAX15]]. This
				attribute MAY be the <a>empty string</a>.

				The <a>un-initialized value</a> of this attribute MUST be
				<code>""</code> (the empty string).
			</dd>
		</dl>

		<pre class="idl">
		dictionary CompositionEventInit : UIEventInit {
			DOMString data = "";
		};
		</pre>

		<dl>
			<dt><code>CompositionEvent . data</code></dt>
			<dd>
				Initializes the <code>data</code> attribute of the
				CompositionEvent object to the characters generated by the IME
				composition.
			</dd>
		</dl>

	<h4 id="events-composition-order">Composition Event Order</h4>

		<p>The Composition Events defined in this specification MUST occur in the following set order relative to one another:</p>

		++---+-------------------+---------------------------------------------+
		=| # | Event Type        | Notes                                       |
		 +---+-------------------+---------------------------------------------+
		+| 1 | compositionstart  |                                             |
		+| 2 | compositionupdate | Multiple events                             |
		+| 3 | compositionend    |                                             |
		++---+-------------------+---------------------------------------------+

	<h4 id="events-composition-handwriting">Handwriting Recognition Systems</h4>

		The following example describes a possible sequence of events when
		composing a text passage <q>text</q> with a handwriting recognition
		system, such as on a pen tablet, as modeled using Composition Events.

		++---+-------------------+---------------------------+------------------------------+
		=| # | Event Type        | {{CompositionEvent}}<br/> | Notes                        |
		 |   |                   | {{CompositionEvent/data}} |                              |
		 +---+-------------------+------------o--------------+------------------------------+
		+| 1 | compositionstart  |        <code>""</code>    |                              |
		+|   |                   |                           | <em>User writes word on      |
		 |   |                   |                           | tablet surface</em>          |
		+| 2 | compositionupdate |    <code>"test"</code>    |                              |
		+|   |                   |                           | <em>User rejects first       |
		 |   |                   |                           | word-match suggestion,       |
		 |   |                   |                           | selects different match</em> |
		+| 3 | compositionupdate |    <code>"text"</code>    |                              |
		+| 4 | compositionend    |    <code>"text"</code>    |                              |
		++---+-------------------+----------------------------------------------------------+

	<h4 id="events-composition-canceling">Canceling Composition Events</h4>

		If a EVENT{keydown} event is canceled then any Composition Events that
		would have fired as a result of that EVENT{keydown} SHOULD not be
		dispatched:

		++---+------------+----------------------------------------------------+
		=| # | Event Type | Notes                                              |
		 +---+------------+----------------------------------------------------+
		+| 1 | keydown    | The <a>default action</a> is prevented, e.g., by   |
		 |   |            | invoking {{Event/preventDefault()}}.               |
		+|   |            | <em>No Composition Events are dispatched</em>      |
		+| 2 | keyup      |                                                    |
		++---+------------+----------------------------------------------------+

		If the initial EVENT{compositionstart} event is canceled then the text
		composition session SHOULD be terminated. Regardless of whether or not
		the composition session is terminated, the EVENT{compositionend} event
		MUST be sent.

		++---+------------------+-----------------------------------------------+
		=| # | Event Type       | Notes                                         |
		 +---+------------------+-----------------------------------------------+
		+| 1 | keydown          |                                               |
		+| 2 | compositionstart | The <a>default action</a> is prevented,       |
		 |   |                  | e.g., by invoking {{Event/preventDefault()}}. |
		+|   |                  | <em>No Composition Events are dispatched</em> |
		+| 3 | compositionend   |                                               |
		+| 4 | keyup            |                                               |
		++---+------------------+-----------------------------------------------+

	<h4 id="events-composition-key-events">Key Events During Composition</h4>

		During the composition session, EVENT{keydown} and EVENT{keyup} events
		MUST still be sent, and these events MUST have the
		{{KeyboardEvent/isComposing}} attribute set to <code>true</code>.

		++---+-------------------+-------------------------------+------------------------------+
		=| # | Event Type        | {{KeyboardEvent}}<br/>        | Notes                        |
		 |   |                   | {{KeyboardEvent/isComposing}} |                              |
		 +---+-------------------+--------------o----------------+------------------------------+
		+| 1 | keydown           | false                         | This is the key event that   |
		 |   |                   |                               | initiates the composition.   |
		+| 2 | compositionstart  |                               |                              |
		+| 3 | compositionupdate |                               |                              |
		+| 4 | keyup             | true                          |                              |
		+|   | ...               |                               | Any key events sent during   |
		 |   |                   |                               | the composition session MUST |
		 |   |                   |                               | have <code>isComposing</code>|
		 |   |                   |                               | set to <code>true</code>.    |
		+| 5 | keydown           | true                          | This is the key event that   |
		 |   |                   |                               | exits the composition.       |
		+| 6 | compositionend    |                               |                              |
		+| 7 | keyup             | false                         |                              |
		++---+-------------------+-------------------------------+------------------------------+

	<h4 id="events-composition-input-events">Input Events During Composition</h4>

		During the composition session, the EVENT{compositionupdate} MUST be
		dispatched after the EVENT{beforeinput} is sent, but before the
		EVENT{input} event is sent.

		++---+-------------------+-----------------------------------------------+
		=| # | Event Type        | Notes                                         |
		 +---+-------------------+-----------------------------------------------+
		+| 1 | beforeinput       |                                               |
		+| 2 | compositionupdate |                                               |
		+|   |                   | <em>Any DOM updates occur at this point.</em> |
		+| 3 | input             |                                               |
		++---+-------------------+-----------------------------------------------+

		<p class="note">
		Most IMEs do not support canceling updates during a composition session.
		</p>

		The EVENT{beforeinput} and EVENT{input} events are sent along with the
		EVENT{compositionupdate} event whenever the DOM is updated as part of
		the composition. Since there are no DOM updates associated with the
		EVENT{compositionend} event, EVENT{beforeinput} and EVENT{input} events
		should not be sent at that time.

		++---+-------------------+-----------------------------------------------+
		=| # | Event Type        | Notes                                         |
		 +---+-------------------+-----------------------------------------------+
		+| 1 | beforeinput       | <em> Canceling this will prevent the DOM      |
		 |   |                   | update and the EVENT{input} event.</em>       |
		+| 2 | compositionupdate |                                               |
		+|   |                   | <em>Any DOM updates occur at this point.</em> |
		+| 3 | input             | <em>Sent only if the DOM was updated.</em>    |
		+| 4 | compositionend    |                                               |
		++---+-------------------+-----------------------------------------------+

	<h4 id="events-composition-types">Composition Event Types</h4>

		<h5 id="event-type-compositionstart"><dfn>compositionstart</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>compositionstart</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{CompositionEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>Start a new composition session when a <a>text composition system</a> is enabled</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								focused element processing the composition</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{CompositionEvent}}.{{CompositionEvent/data}} :
								the original string being edited, otherwise the <a>empty string</a></li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a <a>text
			composition system</a> is enabled and a new composition session is
			about to begin (or has begun, depending on the <a>text composition
			system</a>) in preparation for composing a passage of text. This
			event type is device-dependent, and MAY rely upon the capabilities
			of the text conversion system and how it is mapped into the
			operating system. When a keyboard is used to feed an input method
			editor, this event type is generated after a EVENT{keydown} event,
			but speech or handwriting recognition systems MAY send this event
			type without keyboard events.  Some implementations MAY populate the
			{{CompositionEvent/data}} attribute of the EVENT{compositionstart}
			event with the text currently selected in the document (for editing
			and replacement). Otherwise, the value of the
			{{CompositionEvent/data}} attribute MUST be  the <a>empty string</a>.

			This event MUST be dispatched immediately before a <a>text
			composition system</a> begins a new composition session, and before
			the DOM is modified due to the composition process. The default
			action of this event is for the <a>text composition system</a> to
			start a new composition session. If this event is canceled, the
			<a>text composition system</a> SHOULD discard the current
			composition session.

			<p class="note">
			Canceling the EVENT{compositionstart} <em>event type</em> is
			distinct from canceling the <a>text composition system</a> itself
			(e.g., by hitting a cancel button or closing an <a>IME</a> window).
			</p>

			<p class="note">
			Some IMEs do not support cancelling an in-progress composition
			session (e.g., such as GTK which doesn't presently have such an
			API). In these cases, calling {{Event/preventDefault()}} will not
			stop this event's default action.
			</p>

		<h5 id="event-type-compositionupdate"><dfn>compositionupdate</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>compositionupdate</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{CompositionEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								focused element processing the composition, <code>null</code> if not accessible</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{CompositionEvent}}.{{CompositionEvent/data}} :
								the string comprising the current results of the composition session, which MAY be the
								<a>empty string</a> if the content has been deleted</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> SHOULD dispatch this event during a composition
			session when a <a>text composition system</a> updates its active
			text passage with a new character, which is reflected in the string
			in {{CompositionEvent/data}}.

			In <a>text composition systems</a> which keep the ongoing
			composition in sync with the input control, the
			EVENT{compositionupdate} event MUST be dispatched before the control
			is updated.

			Some <a>text composition systems</a> might not expose this
			information to the DOM, in which case this event will not fire
			during the composition process.

			If the composition session is canceled, this event will be fired
			immediately before the EVENT{compositionend} event, and the
			{{CompositionEvent/data}} attribute will be set to the <a>empty
			string</a>.

		<h5 id="event-type-compositionend"><dfn>compositionend</dfn></h5>

			<table class="event-definition">
				<tr>
					<th>Type</th>
					<td><strong><code>compositionend</code></strong></td>
				</tr>
				<tr>
					<th>Interface</th>
					<td>{{CompositionEvent}}</td>
				</tr>
				<tr>
					<th>Sync / Async</th>
					<td>Sync</td>
				</tr>
				<tr>
					<th>Bubbles</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Trusted Targets</th>
					<td><code>Element</code></td>
				</tr>
				<tr>
					<th>Cancelable</th>
					<td>No</td>
				</tr>
				<tr>
					<th>Composed</th>
					<td>Yes</td>
				</tr>
				<tr>
					<th>Default action</th>
					<td>None</td>
				</tr>
				<tr>
					<th>Context<br/>(trusted events)</th>
					<td>
						<ul>
							<li>{{Event}}.{{Event/target}} :
								focused element processing the composition</li>
							<li>{{UIEvent}}.{{UIEvent/view}} :
								<a><code>Window</code></a></li>
							<li>{{UIEvent}}.{{UIEvent/detail}} :
								<code>0</code></li>
							<li>{{CompositionEvent}}.{{CompositionEvent/data}} :
								the string comprising the final result of the composition session, which MAY be the
								<a>empty string</a> if the content has been deleted or if the composition process has been canceled</li>
						</ul>
					</td>
				</tr>
			</table>

			A <a>user agent</a> MUST dispatch this event when a <a>text
			composition system</a> completes or cancels the current composition
			session, and the EVENT{compositionend} event MUST be dispatched
			after the control is updated.

			This event is dispatched immediately after the <a>text composition
			system</a> completes the composition session (e.g., the <a>IME</a>
			is closed, minimized, switched out of focus, or otherwise dismissed,
			and the focus switched back to the <a>user agent</a>).

</section>
